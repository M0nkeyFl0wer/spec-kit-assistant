import fs from 'fs-extra';
import path from 'path';
import yaml from 'yaml';
import { execSync } from 'child_process';

/**
 * üîß GitHub Spec Kit Integration
 * Ensures we're actually implementing the real GitHub Spec Kit underneath all the fun UX
 */
export class GitHubSpecKitIntegration {
  constructor() {
    this.specKitRepoUrl = 'https://github.com/github/spec-kit';
    this.specKitPath = path.join(process.cwd(), '.spec-kit');
    this.specFormats = {
      problem: 'PROBLEM.md',
      solution: 'SOLUTION.md',
      specification: 'SPECIFICATION.md',
      implementation: 'IMPLEMENTATION.md',
    };
  }

  async ensureSpecKitInstalled() {
    try {
      // Check if spec-kit is already available
      if (!await fs.pathExists(this.specKitPath)) {
        console.log('üì¶ Installing GitHub Spec Kit...');

        // Clone the actual spec-kit repo
        execSync(`git clone ${this.specKitRepoUrl} ${this.specKitPath}`, { stdio: 'pipe' });
        console.log('‚úÖ GitHub Spec Kit installed');
      }

      return true;
    } catch (error) {
      console.log('‚ö†Ô∏è Could not install GitHub Spec Kit automatically');
      console.log('Using built-in spec generation instead');
      return false;
    }
  }

  async generateSpecKitCompliantSpec(projectContext) {
    // Generate spec following GitHub Spec Kit format
    const spec = {
      problem: this.generateProblemStatement(projectContext),
      solution: this.generateSolutionOverview(projectContext),
      specification: this.generateTechnicalSpecification(projectContext),
      implementation: this.generateImplementationPlan(projectContext),
    };

    return spec;
  }

  generateProblemStatement(context) {
    const problem = `# Problem Statement

## What problem are we solving?

${context.deepContext?.problem || context.vision || 'Problem description needed'}

## Who has this problem?

${context.deepContext?.audience || 'Target audience needs definition'}

## Why is this problem important?

${context.deepContext?.importance || 'Business case needs definition'}

## Success criteria

- ${context.deepContext?.emotion ? `Users feel: ${context.deepContext.emotion}` : 'User satisfaction criteria needed'}
- Functional requirements met
- Performance targets achieved
- Adoption metrics reached

## Out of scope

- Features not included in initial release
- Future enhancements
- Non-essential functionality

---
*Generated by Spec Kit Assistant - GitHub Spec Kit Compliant*
`;

    return problem;
  }

  generateSolutionOverview(context) {
    const solution = `# Solution Overview

## High-level approach

${context.specialFeature?.description || 'Solution approach description needed'}

## Key features

${this.formatFeatureList(context)}

## User experience

${context.specialFeature?.mechanics || 'User experience flow description needed'}

## Technical approach

- **Project type**: ${context.type || 'web-app'}
- **Timeline**: ${context.timeline || 'mvp'}
- **Team size**: ${context.teamSize || 'solo'}
- **Experience level**: ${context.experienceLevel || 'intermediate'}

## Architecture overview

${this.generateArchitectureOverview(context)}

## Risks and mitigations

${this.generateRiskAssessment(context)}

---
*Generated by Spec Kit Assistant - GitHub Spec Kit Compliant*
`;

    return solution;
  }

  generateTechnicalSpecification(context) {
    const spec = `# Technical Specification

## System architecture

${this.generateSystemArchitecture(context)}

## Data models

${this.generateDataModels(context)}

## API design

${this.generateAPIDesign(context)}

## Frontend specification

${this.generateFrontendSpec(context)}

## Backend specification

${this.generateBackendSpec(context)}

## Database design

${this.generateDatabaseDesign(context)}

## Security considerations

- Authentication: ${context.authentication || 'TBD'}
- Authorization: Role-based access control
- Data protection: Encryption at rest and in transit
- Input validation: Server-side validation for all inputs

## Performance requirements

- Response time: < 200ms for API calls
- Throughput: Support concurrent users
- Scalability: Horizontal scaling capability
- Availability: 99.9% uptime target

## Testing strategy

- Unit tests: Coverage > 80%
- Integration tests: API and database tests
- End-to-end tests: Critical user journeys
- Performance tests: Load and stress testing

---
*Generated by Spec Kit Assistant - GitHub Spec Kit Compliant*
`;

    return spec;
  }

  generateImplementationPlan(context) {
    const implementation = `# Implementation Plan

## Development phases

### Phase 1: Foundation (Week 1)
- Project setup and configuration
- Development environment setup
- Basic project structure
- CI/CD pipeline setup

### Phase 2: Core Development (Weeks 2-4)
- ${this.generateCoreFeatures(context)}
- Database setup and models
- API endpoint implementation
- Frontend component development

### Phase 3: Integration (Week 5)
- Frontend-backend integration
- Third-party service integration
- Error handling and validation
- Security implementation

### Phase 4: Testing & Polish (Week 6)
- Comprehensive testing
- Bug fixes and optimizations
- Documentation completion
- Deployment preparation

## Technical tasks

${this.generateTechnicalTasks(context)}

## Testing plan

${this.generateTestingPlan(context)}

## Deployment strategy

${this.generateDeploymentStrategy(context)}

## Monitoring and maintenance

- Application monitoring
- Error tracking
- Performance monitoring
- User analytics

## Success metrics

- Functional: All features working as specified
- Performance: Meets performance requirements
- Quality: Passes all tests and reviews
- User: Positive user feedback and adoption

---
*Generated by Spec Kit Assistant - GitHub Spec Kit Compliant*
`;

    return implementation;
  }

  formatFeatureList(context) {
    const features = [];

    if (context.specialFeature) {
      if (typeof context.specialFeature === 'string') {
        features.push(`- ${context.specialFeature}`);
      } else {
        features.push(`- ${context.specialFeature.description}`);
      }
    }

    // Add type-specific features
    const typeFeatures = {
      'web-app': ['User authentication', 'Responsive design', 'Data management'],
      'mobile-app': ['Native UI', 'Offline capability', 'Push notifications'],
      'api-service': ['RESTful endpoints', 'Authentication', 'Rate limiting'],
      'cli-tool': ['Command interface', 'Configuration management', 'Help system'],
      'data-project': ['Data processing', 'Visualization', 'Export functionality'],
    };

    const defaultFeatures = typeFeatures[context.type] || typeFeatures['web-app'];
    defaultFeatures.forEach((feature) => features.push(`- ${feature}`));

    return features.join('\n');
  }

  generateArchitectureOverview(context) {
    const architectures = {
      'web-app': `
**Client-Server Architecture**
- Frontend: ${context.frontend || 'React'} application
- Backend: ${context['backend-api'] || 'REST'} API
- Database: ${context.database || 'PostgreSQL'}
- Deployment: Cloud hosting platform`,

      'mobile-app': `
**Mobile Application Architecture**
- Platform: ${context.platform || 'React Native'}
- Backend: API services
- Data: Local storage with cloud sync
- Deployment: App stores`,

      'api-service': `
**Microservice Architecture**
- API Layer: ${context['rest-vs-graphql'] || 'REST'} endpoints
- Business Logic: Service layer
- Data Layer: ${context.database || 'PostgreSQL'}
- Deployment: Container orchestration`,

      'cli-tool': `
**Command-Line Tool Architecture**
- Interface: Command-line parser
- Core Logic: Business logic modules
- Configuration: File-based configuration
- Distribution: Package manager`,

      'data-project': `
**Data Processing Architecture**
- Ingestion: ${context['data-sources'] || 'Multiple sources'}
- Processing: ${context['processing-frequency'] || 'Batch processing'}
- Storage: ${context.storage || 'Data warehouse'}
- Visualization: Dashboard interface`,
    };

    return architectures[context.type] || architectures['web-app'];
  }

  generateRiskAssessment(context) {
    const risks = [
      '**Technical Risks**: Complex integrations, performance issues',
      '**Timeline Risks**: Scope creep, dependency delays',
      '**Resource Risks**: Team availability, skill gaps',
      '**External Risks**: Third-party service changes, compliance requirements',
    ];

    // Add reasoning-based risks
    Object.keys(context).forEach((key) => {
      if (key.endsWith('_reasoning') && context[key].risks) {
        risks.push(`**${key.replace('_reasoning', '')} Risk**: ${context[key].risks}`);
      }
    });

    return risks.join('\n');
  }

  generateSystemArchitecture(context) {
    return `## Component diagram
\`\`\`
[User Interface] -> [API Layer] -> [Business Logic] -> [Data Layer]
\`\`\`

## Technology stack
- **Frontend**: ${context.frontend || 'React'}
- **Backend**: ${context['backend-api'] || 'Node.js/Express'}
- **Database**: ${context.database || 'PostgreSQL'}
- **Deployment**: ${context.deployment || 'Cloud platform'}`;
  }

  generateDataModels(context) {
    return `## Core entities
- User: Authentication and profile data
- Project: Main business entity
- Session: User interaction tracking

## Data relationships
- User has many Projects
- Project belongs to User
- Session belongs to User`;
  }

  generateAPIDesign(context) {
    return `## Endpoint specification
- GET /api/health - Health check
- POST /api/auth/login - User authentication
- GET /api/projects - List projects
- POST /api/projects - Create project
- GET /api/projects/:id - Get project details
- PUT /api/projects/:id - Update project
- DELETE /api/projects/:id - Delete project`;
  }

  generateFrontendSpec(context) {
    return `## Component structure
- App: Root component
- Header: Navigation and user menu
- ProjectList: Display projects
- ProjectForm: Create/edit projects
- Dashboard: Main user interface

## State management
- ${context.frontend === 'react' ? 'React Context/Redux' : 'Component state'}
- User authentication state
- Project data state`;
  }

  generateBackendSpec(context) {
    return `## Service architecture
- Authentication service
- Project management service
- Data validation service
- File storage service

## Middleware
- CORS configuration
- Request logging
- Error handling
- Rate limiting`;
  }

  generateDatabaseDesign(context) {
    return `## Table structure
### users
- id (PRIMARY KEY)
- email (UNIQUE)
- password_hash
- created_at
- updated_at

### projects
- id (PRIMARY KEY)
- user_id (FOREIGN KEY)
- name
- description
- status
- created_at
- updated_at`;
  }

  generateCoreFeatures(context) {
    const features = [];

    if (context.specialFeature?.description) {
      features.push(`- ${context.specialFeature.description} implementation`);
    }

    features.push('- User authentication system');
    features.push('- Main application logic');
    features.push('- Data persistence layer');

    return features.join('\n');
  }

  generateTechnicalTasks(context) {
    return `## Backend tasks
- [ ] API endpoint implementation
- [ ] Database schema creation
- [ ] Authentication middleware
- [ ] Data validation logic

## Frontend tasks
- [ ] Component development
- [ ] State management setup
- [ ] API integration
- [ ] UI/UX implementation

## Infrastructure tasks
- [ ] Development environment setup
- [ ] CI/CD pipeline configuration
- [ ] Deployment automation
- [ ] Monitoring setup`;
  }

  generateTestingPlan(context) {
    return `## Unit tests
- Backend service functions
- Frontend component logic
- Utility functions
- Data validation

## Integration tests
- API endpoint testing
- Database operations
- Third-party service integration
- Authentication flow

## End-to-end tests
- User registration and login
- Core user workflows
- Error handling scenarios
- Cross-browser compatibility`;
  }

  generateDeploymentStrategy(context) {
    return `## Environment setup
- **Development**: Local development environment
- **Staging**: Testing environment with production data
- **Production**: Live environment with monitoring

## Deployment process
1. Code review and approval
2. Automated testing pipeline
3. Staging deployment and testing
4. Production deployment
5. Post-deployment monitoring

## Rollback strategy
- Database backup and restore procedures
- Application version rollback capability
- Feature flag toggling for quick disabling`;
  }

  async saveSpecKitFiles(spec, outputDir) {
    await fs.ensureDir(outputDir);

    // Save each spec file in GitHub Spec Kit format
    for (const [type, content] of Object.entries(spec)) {
      const filename = this.specFormats[type] || `${type.toUpperCase()}.md`;
      const filepath = path.join(outputDir, filename);
      await fs.writeFile(filepath, content);
    }

    // Create the spec kit index file
    const indexContent = this.generateSpecKitIndex(spec);
    await fs.writeFile(path.join(outputDir, 'README.md'), indexContent);

    console.log(`‚úÖ GitHub Spec Kit compliant files saved to: ${outputDir}`);
    return outputDir;
  }

  generateSpecKitIndex(spec) {
    return `# Project Specification

This specification follows the [GitHub Spec Kit](https://github.com/github/spec-kit) format.

## Specification Documents

- [üìã Problem Statement](./PROBLEM.md) - What problem we're solving
- [üí° Solution Overview](./SOLUTION.md) - High-level approach
- [üîß Technical Specification](./SPECIFICATION.md) - Detailed technical design
- [üöÄ Implementation Plan](./IMPLEMENTATION.md) - Development roadmap

## Generated by Spec Kit Assistant

This specification was generated through conversational consultation with Spec, your loyal dog assistant, ensuring both human insight and technical rigor.

---
*Following GitHub Spec Kit standards for consistent, reviewable specifications*
`;
  }

  async validateSpecKitCompliance(spec) {
    const validation = {
      valid: true,
      issues: [],
      score: 0,
    };

    // Check required sections
    const requiredSections = ['problem', 'solution', 'specification', 'implementation'];

    for (const section of requiredSections) {
      if (!spec[section] || spec[section].length < 100) {
        validation.issues.push(`${section} section is too short or missing`);
        validation.valid = false;
      } else {
        validation.score += 25;
      }
    }

    // Check for key content
    const contentChecks = [
      { section: 'problem', mustContain: ['problem', 'who', 'why'], weight: 10 },
      { section: 'solution', mustContain: ['approach', 'features', 'architecture'], weight: 10 },
      { section: 'specification', mustContain: ['system', 'api', 'security'], weight: 10 },
      { section: 'implementation', mustContain: ['phases', 'tasks', 'testing'], weight: 10 },
    ];

    for (const check of contentChecks) {
      const content = spec[check.section]?.toLowerCase() || '';
      const matches = check.mustContain.filter((term) => content.includes(term));

      if (matches.length < check.mustContain.length) {
        validation.issues.push(`${check.section} missing key topics: ${check.mustContain.filter((term) => !content.includes(term)).join(', ')}`);
      } else {
        validation.score += check.weight;
      }
    }

    return validation;
  }
}

export default GitHubSpecKitIntegration;
